---
title: Clojure by Example

includes:

search: true
---

# Hello, world!!

```clojure
user=> (println "hello, world")
hello, world
nil
```

Our first Clojure code is, of course, printing "Hello, world!".

# Booleans

```clojure
user=> true
true

user=> false
false
```

`true` and `false` are values of *Boolean* type just like in other programming languages.

# Strings

## Literals

```clojure
user=> "Hi, there!"
"Hi, there!"G
```

</br>

You can create a string by double-quoting text.

## Concatination


```clojure
user=> (+ "Good" " " "morning")

ClassCastException java.lang.String cannot be cast to java.lang.Number  clojure.lang.Numbers.add (Numbers.java:126)
```

</br>

`+` operator *doesn't* work to concat strings against your expectation.


```
user=> (use '[clojure.string :only [join]])
nil

user=> (join "" ["Good" " " "morning"])
"Good morning"
```

</br>
</br>
</br>
</br>

Instead, you can use `clojure.string/join`

# Integers

## Addition

```clojure
user=> (+ 2 3)
5
```

## Subtraction

```clojure
user=> (- 10 3)
7
```

## Multiplication

```clojure
user=> (* 10 2)
20
```

## Division

```clojure
user=> (/ 4 2)
2
```

```clojure
user=> (/ 4 3)
4/3
```

</br>
</br>
</br>
</br>
</br>

Interesting thing is that fraction is represented by ratio.

## Modulo

```clojure
user=> (mod 3 2)
1
```

<br>

Get modulus with `mod`

## Max

```clojure
user=> (max 1 2 3 4 5)  
5
```

<br>

Get the greatest and smallest number with `max`.

## Min

```clojure
user=> (min 5 4 3 2 1)
1
```

<br>

Get the smallest number with `min`.

## Power

```clojure
user=> (defn power
  [x n]
  (reduce * (repeat n x))
)

user=> (power 2 3)
8
```

Clojure doesn't provide built-in function for exponential operation.

Define a function `power`. `reduce` takes a sequence generated by `repeat` and compute `*` against each element of the sequence and returns the sum. The sum is used to do `*` against the next element of the sequence.

## Bigint

```clojure
user=> (+ (bigint Long/MAX_VALUE) 10)
9223372036854775817N
```

<br>

You can use `bigint` to handle really big number.

# Lists

## Literal

```clojure
user=> `(1 2 3)
(1 2 3)
```

<br>

Lists are simple collection of values. You can create a list by grouping values with paren with **`** at the top. We need ``` ` ``` because list will be evaluated without it.

## Get element

```clojure
user=> (nth `(1 2 3) 1)
2
```

<br>

To get a value from list, you use `nth` with index number. Index starts from 0

## Count

```clojure
user=> (count `(1 2 3) )
3
```

<br>

To count how many values in the list, you use `count`.

## Add element

```clojure
user=> (conj `(1 2 3) 4)
(4 1 2 3)
```

<br>

To add a value to the list, you use `conj` (conj[oin]). Note that the new value is added to the top.

## Remove element

How to remove a value from a list? You can't really remove a value from list in Clojure. That's not what list is supposed to do.
If you are writing a program that needs to remove from collection, you should use other type of collection such as `Set`.

# Vectors

You can think of `Vector` as efficient version of `List`. It's more practical data storage of multiple values than `List`.

## Literal

```clojure
user=> [1 2 3]
[1 2 3]
```

<br>

You can create a vector by grouping values with square brackets. Unlike list, you don't need ``` ` ``` because vector will not be evaluated unlike list.

## Get element

```clojure
user=> (nth [1 2 3] 1)
2
```
<br>
To get a value from vector, you need to specify the index of the value.

```clojure
user=> (first [1 2 3])
1

user=> (last [1 2 3])
3
```

<br>
<br>

`Vetor` has convenient functions to access elements. To get first and second element, you use `first` and `second`.

## Add element

```clojure
user=> (conj [1 2 3] 4)
[1 2 3 4]
```

<br>

To add a value, you use `conj` (conj[oin]). **Note that the new value is added to the bottom.**

## Get index

```clojure
user=>  (.indexOf [1 2 3] 2)
1
```

<br>

You can get the index of a value in vector with `.indexOf`.

```clojure
user=>  (.indexOf [1 2 3] 4)
-1
```

<br>
<br>

Returns `-1` if the value doesn't exist.


# Sets

`Sets` are unordered collection of values, meaning that the order of values are not guaranteed.

## Literal

```clojure
user=> #{1 2 3}
#{1 3 2}
```

<br>

You can create a set by grouping values with `#{}`. I get the order of 1 -> 3 -> 2 on my computer but you may get different order since the order is not guaranteed

## Get element

```clojure
user=> (sort (conj #{1 2 3} 4))
(1 2 3 4)
```

<br>

To get sorted order, you use `sort`.

## Add element

```clojure
user=> (conj #{1 2 3} 4)
#{1 4 3 2}
```

<br>

To add a value, you use `conj` (conj[oin]).

```clojure
user=> (conj (conj #{1 2 3} 4) 4)
#{1 4 3 2}
```

<br>
<br>

One important trait of set is that **it does not contain an element more than once.**

## Remove element

```clojure
user=> (disj #{1 2 3} 1)
#{3 2}
```

<br>

To create a set where a value is removed (basically removing a value from set), you use `disj` (disj[oin]).

```clojure
user=> (disj #{1 2 3} 4)
#{1 3 2}
```

<br>
<br>

If `disj` value that the set doesn't contain, it returns the original set.

## Select elements

```clojure
user=> (clojure.set/select odd? #{1 2 3} )
#{1 3}
```

<br>

To select certain values from a set, you use `select`. `odd?` returns boolean for each element. This example returns a new set which only contains odd numbers.

## Check if element exists

```clojure
user=> (contains? #{1 2 3} 1)
true

user=> (contains? #{1 2 3} 4)
false
```

<br>

To check if a value is contained in a set, you use `contains?`.

## Check if a set is part of other set

```clojure
user=>  (clojure.set/subset? #{1 2} #{1 2 3 4})
true

user=>  (clojure.set/subset? #{1 5} #{1 2 3 4})
false
```

<br>

To check if a set is part of another set, you use `subset?`.

## Check if a set includes other set

```clojure
user=>  (clojure.set/superset? #{1 2 3} #{1 2})
true
```

<br>

To check if a set includes another set, you use `superset?`.

# Maps

`Maps` are key-value data structure to store multiple values.

## Literal

```clojure
user=> {"Apple" "Mac" "Microsoft" "Windows"}
{"Apple" "Mac" "Microsoft" "Windows"}
```

<br>

You can create a map by grouping values with `{}`.


## Get element

```clojure
user=> (get {"Apple" "Mac" "Microsoft" "Windows"} "Apple")
"Mac"
```

<br>

To get value from key, you use `get`.

```clojure
user=>  (get {"Apple" "Mac" "Microsoft" "Windows"} "Linux")
nil
```

<br>
<br>

You get `nil` when key doesn't exist.

## Add element

```clojure
user=> (assoc {"Apple", "Mac" "Microsoft" "Windows"} "Commodore" "Amiga")
{"Commodore" "Amiga", "Apple" "Mac", "Microsoft" "Windows"}
```

<br>

To add a key-value pair, you use `assoc`.

```clojure
user=> (assoc {"Apple", "Mac" "Microsoft" "Windows"} "Apple" "iOS")
{"Apple" "iOS", "Microsoft" "Windows"}
```

<br>
<br>

If key already exists, it replace the value.

## Combine maps

```clojure
user=> (merge {"Apple", "Mac" "Microsoft" "Windows"} {1 2})
{1 2, "Apple" "Mac", "Microsoft" "Windows"}
```

<br>

To combine two maps, you use `merge`.

## Keys

```clojure
(keys {"Apple", "Mac" "Microsoft" "Windows"})
```

<br>

To get all keys from a map, you use `keys`.

## Vals

```clojure
(keys {"Apple", "Mac" "Microsoft" "Windows"})
```

<br>

To get all values from a map, you use `vals`.

# Sequences

`Secuqnces` are logical lists that are not tied to a particular implementation. What does it mean? It means that you can apply the same functions to any types of collections without worrying about what types of collections that you are dealing with.

```clojure
user=> (map inc [ 1 2 3 ])
(2 3 4)

user=> (map inc `( 1 2 3 ))
(2 3 4)

user=> (map inc #{ 1 2 3 })
(2 4 3)



user=> (map println {:a 1 :b 2 :c 3} )
[:c 3]
[:b 2]
[:a 1]
(nil nil nil)
```

<br>

Using map for `Vectors`.

<br>

Using map for `Lists`.

<br>

Using map for `Sets`.

<br>

Using map for `Maps`. We are using `println` for the function that we apply since `inc` doesn't work here, but this doesn't hurt the idea that you can use `map` for any collections.

```clojure
user=> (type (map inc [ 1 2 3 ]))
clojure.lang.LazySeq

user=> (type (map inc `( 1 2 3 )))
clojure.lang.LazySeq

user=> (type (map inc #{ 1 2 3 }))
clojure.lang.LazySeq
```

<br>
<br>
<br>
<br>

As you can see, the type of all returned values is `LazySeq`.

<br>
<br>
<br>
<br>
<br>
<br>

`Sequences` **are the most important data abstraction in Clojure.**

## Map

```clojure
user=> (map inc [ 1 2 3 ])
(2 3 4)
```

<br>

To apply a function to each element of collection, you use `map`.

## Reduce

```clojure
user=> (reduce + [1 2 3 4])
10
```

<br>

`reduce` boils down values in a collection into a single value by applying a function.

```clojure
user=> (reduce + -10 [1 2 3 4])
0
```

<br>
<br>

You can pass a default value in the second argument. When default value is given, `reduce` will use it as a starting point.

## Into

To convert from one type of collection to another, you use `into`.

```clojure

user=> (into [] `(1 2 3))
[1 2 3]
```

<br>
<br>

Converting a list to a vector.


```clojure
user=> (into (list) [1 2 3])
(3 2 1)
```

<br>
<br>

Converting a vector to a list.

```clojure
user=> (into #{} [1 2 3])
#{1 3 2}
```

<br>
<br>

Converting a vector to a set.

```clojure
user=> (into [] #{1 2 3})
[1 3 2]
```

<br>
<br>

Converting a set to a vector.

```clojure
user=> (into {} [[:a 1] [:b 2] [:c 3]])
{:a 1, :b 2, :c 3}
```

<br>
<br>

Converting a nested vector into a map.

```clojure
user=> (into [] {:a 1 :b 2 :c 3})
[[:c 3] [:b 2] [:a 1]]
```

<br>
<br>

Converting a map to a nested vector.

```clojure
user=> (reduce conj #{} [1 2 3])
#{1 3 2}
```

<br>
<br>

`into` is just a thin wrapper around `reduce`. In fact, you can easily rewrite previous examples with `reduce`.

## Iterate

```clojure
user=> (iterate + 0)

```

<br>

You can get a sequence of infinite integers with `iterate`. Be careful, though. Running this example will freeze your terminal since the computation continues forever.

## Range

```clojure
user=> (range 5 10)
(5 6 7 8 9)
```

<br>

To generates a sequence of numbers between two points, you can use `range`.

```clojure
user=> (range 0 100 5)
(0 5 10 15 20 25 30 35 40 45 50 55 60 65 70 75 80 85 90 95)
```

<br>
<br>

You can get integers by every x within the range. In this case, we get a sequence of integers at every 5.

## Repeatedly

```clojure
user=> (repeatedly 5 (fn [] (println "hi!")) )
hi!
hi!
hi!
hi!
hi!
(nil nil nil nil nil)
```

<br>

To repeat something over and over again, you use `repeatedly`. We are passing an anonymous function `(fn [] (println "hi!"))` because the second argument must be a function.



## Lazy Sequence

Most of Clojure’s sequence functions are **lazy**.
